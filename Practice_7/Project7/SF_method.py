# Функция для кодирования по алгоритму Шеннона – Фано.
def sf_encode(arr, current_result):
    quantity = sum(map(lambda x: x[1], arr))  # Общее количество символов.
    half = 0  # Количество символов в первой группе (первой половине).
    index = 0  # Индекс элемента массива arr, добавляемого в первую группу в последнюю очередь (последнего в группе).
    for arr_element_index, arr_element in enumerate(arr):  # Для каждого индекса и элемента массива arr:
        half += arr_element[1]  # Добавление кол-ва повторений текущего символа в кол-во символов в первой группе.
        if half * 2 >= quantity:  # Если удвоенное кол-во символов в первой группе не меньше общего кол-ва символов:
            # Если разница между удвоенным кол-вом символов в первой группе и общим кол-вом символов меньше
            # разницы между удвоенным кол-вом символов в первой группе без кол-ва повторений последнего рассм. элемента:
            # следующий элемент после последнего рассматриваемого включается в первой группу, иначе:
            # последний рассматриваемый элемент остаётся последним в первой группе.
            index = arr_element_index + (abs(2 * half - quantity) < abs(2 * (half - arr_element[1]) - quantity))
            break  # Индекс последнего элемента первой группы определён — выход из цикла.
    arr0, arr1 = [], []  # Массивы из элементов первой и второй групп соответственно.
    for arr_element in arr[:index]:  # Для каждого элемента массива до элемента с индексом index:
        arr_element[2] += '0'  # При кодировании элементов первой группы будет добавляться '0'.
        arr0.append(arr_element)  # Добавление элемента в первую группу.
    for arr_element in arr[index:]:  # Для каждого элемента массива до элемента с индексом index:
        arr_element[2] += '1'  # При кодировании элементов второй группы будет добавляться '1'.
        arr1.append(arr_element)  # Добавление элемента во вторую группу.
    if len(arr1) == 1:  # Если во второй группе один элемент:
        current_result.append(arr1)  # Добавить вторую группу в массив с текущим результатом кодирования.
    else:  # Иначе (если во второй группе несколько элементов, то нужно продолжать разбиение):
        sf_encode(arr1, current_result)  # Рекурсивный запуск функции для второй группы и массива с текущим результатом.
    if len(arr0) == 1:  # Если в первой группе один элемент:
        current_result.append(arr0)  # Добавить первую группу в массив с текущим результатом кодирования.
    else:  # Иначе (если в первой группе несколько элементов, то нужно продолжать разбиение):
        sf_encode(arr0, current_result)  # Рекурсивный запуск функции для первой группы и массива с текущим результатом.
    return current_result  # Возврат массива с результатом кодирования символов.


# Главная функция.
def main():

    # Кодирование текста из файла.

    result = []  # Объявление массива с результатом кодирования символов.
    file = open("file.txt", encoding='utf8')  # Создание файла "file.txt" с кодировкой 'utf8' и его открытие на чтение.
    # Запись всех символов из файла в переменную text.
    text = file.read()
    file.close()  # Закрытие файла file.
    dictionary = {}  # Объявление словаря dictionary.
    for ch in text:  # Для каждого символа ch в тексте text:
        # Увеличение элемента словаря dictionary с ключом ch на 1 при наличии ключа ch.
        # Присвоение элементу словаря dictionary с ключом ch значения 0 при предварительном отсутствии ключа ch:
        dictionary[ch] = dictionary.get(ch, 0) + 1
    ch_quantity = len(text)
    print(f"Общее количество символов в тексте: {ch_quantity}.")
    # Сортировка словаря по кол-ву повторений элементов в тексте.
    dictionary = sorted(dictionary.items(), key=lambda x: x[1], reverse=True)
    array = []  # Объявление массива для дальнейшей передачи его в функцию для кодирования.
    for element in dictionary:  # Для каждого элемента element словаря dictionary:
        array.append(list(element) + [''])  # Добавление в конец массива array списка из [element] и [''].
    result = sf_encode(array, result)[::-1]  # Запись в массив с результатом перевёрнутого массива от функции sf_encode.
    print("Кодирование символов методом Шеннона-Фано:")
    for i in range(len(result)):  # Для i от 0 до длины массива result:
        result[i] = result[i][0]  # Удаление вложенности массивов.
        print(result[i])  # Вывод элемента массива result с индексом i.
    # Создание файла "file_code.txt" с кодировкой 'utf8' и его открытие на запись.
    file_code = open("file_code.txt", "w", encoding='utf8')
    for ch in text:  # Для каждого символа ch в тексте text:
        for element in result:  # Для каждого элемента element массива result:
            if element[0] == ch:  # Если текущий кодируемый символ совпадает с текущим символом в тексте:
                file_code.write(element[2])  # Запись кода данного символа в файл file_code.
    file_code.close()  # Закрытие файла file_code.
    print('Кодирование текста методом Шеннона-Фано завершено. Результат сохранён в файл "file_code.txt".')

    # Оценка сжатия текста.

    print(f"Объём незакодированной фразы: V(text) = {ch_quantity} * 8 бит = {ch_quantity * 8} бит.")
    volume_code = 0  # Объём закодированной фразы.
    for element in result:  # Для каждого элемента element массива result:
        volume_code += len(element[2]) * element[1]  # Кол-во символов в закод. символе * на кол-во повторений символа.
    print(f"Объём закодированной фразы: V(code) = {volume_code} бит.")
    k = volume_code / (ch_quantity * 8)  # Коэффициент сжатия.
    k = float('{:.3f}'.format(k))  # Запись k с тремя знаками после запятой.
    print(f"Коэффициент сжатия: k = {volume_code} бит / {ch_quantity * 8} бит ≊ {k}.")

    # Декодирование текста из файла.

    # Создание файла "file_code.txt" с кодировкой 'utf8' и его открытие на чтение.
    file_code = open("file_code.txt", encoding='utf8')
    code = file_code.read()  # Запись всех символов из файла file_code в переменную code.
    file_code.close()  # Закрытие файла file_code.
    # Создание файла "file_decode.txt" с кодировкой 'utf8' и его открытие на запись.
    file_decode = open("file_decode.txt", "w", encoding='utf8')
    code_piece = ""  # Текущий рассматриваемый фрагмент закодированного текста.
    for ch in code:  # Для каждого символа ch в закодированном тексте code:
        code_piece += ch  # Добавление символа ch в code_piece.
        for element in result:  # Для каждого элемента element массива result:
            if code_piece == element[2]:  # Если code_piece совпадает с кодом текущего кодируемого символа:
                file_decode.write(element[0])  # Запись декодированного символа в файл file_decode.
                code_piece = ""  # Очистка текущего рассматриваемого фрагмента закодированного текста.
    file_decode.close()  # Закрытие файла file_decode.
    print('Декодирование текста методом Шеннона-Фано завершено. Результат сохранён в файл "file_decode.txt".')


if __name__ == "__main__":
    main()
