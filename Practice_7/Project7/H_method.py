import heapq  # Импорт модуля heapq для работы с мин. кучей.
from collections import Counter  # Импорт словаря с поддержкой счётчика для каждого объекта.
from collections import namedtuple  # Импорт кортежа с индексируемыми и итерируемыми полями для поиска по атрибутам.


# Класс для "ветвей" дерева (внутренних узлов).
class Node(namedtuple("Node", ["left", "right"])):
    # Функция для обхода дерева.
    def walk(self, code, pre):
        self.left.walk(code, pre + "0")  # Переход к левому потомку с добавлением "0" к префиксу.
        self.right.walk(code, pre + "1")  # Переход к правому потомку с добавлением "1" к префиксу.


# Класс для "листьев" дерева.
class Leaf(namedtuple("Leaf", ["char"])):
    def walk(self, code, pre):  # Построенный код для данного символа.
        code[self.char] = pre or "0"  # Если строка длиной 1, то pre = "", для этого случая — pre = "0".


# Функция кодирования строки методом Хаффмана.
def huffman_encode(s):
    h = []  # Объявление очереди с приоритетами и её инициализация пустой.
    print("Таблица частот символов:")
    print("'<символ>': <частота> (<кол-во повторений>)")
    # Построение очереди циклом с уникальным для всех листьев счётчиком.
    for ch, freq in Counter(s).items():
        print("'{}':".format(ch), '{:.3f}'.format(freq / len(s)), end=' ')
        print(f"({freq})")
        # Очередь будет представлена частотой символа, счётчиком и самим символом.
        h.append((freq, len(h), Leaf(ch)))
    heapq.heapify(h)  # Построение очереди с приоритетами.
    count = len(h)  # Объявление счётчика и его инициализация со значением длины очереди.
    while len(h) > 1:  # Пока в очереди больше 1 элемента:
        # Элемент с минимальной частотой — левый узел.
        freq1, _count1, left = heapq.heappop(h)
        # Следующий элемент с минимальной частотой — правый узел.
        freq2, _count2, right = heapq.heappop(h)
        # Вставка в очередь нового элемента, у которого частота равна сумме частот полученных из очереди элементов.
        heapq.heappush(h, (freq1 + freq2, count, Node(left, right)))  # Добавление нового узла с потомками left, right.
        count += 1  # Увеличение значения счётчика на 1 (при добавлении нового элемента дерева).
    code = {}  # Объявление словаря кодов символов и его инициализация пустым.
    # Если строка пустая, то очередь будет пустая — обхода не будет.
    if h:  # Если в очереди 1 элемент:
        # В очереди 1 элемент, приоритет которого не важен, а сам элемент — корень дерева.
        [(_freq, _count, root)] = h
        root.walk(code, "")  # Обход дерева от корня и заполнение словаря для получения кодирования Хаффмана.
    return code  # Возврат словаря символов и соответствующих им кодов Хаффмана.


# Функция декодирования строки по кодам Хаффмана.
def huffman_decode(encoded, code):
    decoded = []  # Объявление массива символов расшифрованной строки и его инициализация пустым.
    enc_ch = ""  # Объявление переменной значения закодированного символа и её инициализация пустой строкой.
    # Обход закодированной строки по символам.
    for ch in encoded:  # Для каждого символа ch в строке encoded.
        enc_ch += ch  # Добавление текущего символа ch к строке закодированного символа enc_ch.
        # Нахождение закодированного символа в словаре кодов.
        for dec_ch in code:  # Для каждого ключа dec_ch в словаре code.
            if code.get(dec_ch) == enc_ch:  # Если закодированный символ найден:
                decoded.append(dec_ch)  # Добавление в конец массива decoded значения расшифрованного символа.
                enc_ch = ""  # Обнуление значения закодированного символа.
                break  # Закодированный символ найден — выход из цикла.
    return "".join(decoded)  # Возврат значения расшифрованной строки.


# Главная функция.
def main():

    # Кодирование текста из файла.

    file = open("file.txt", encoding='utf8')  # Создание файла "file.txt" с кодировкой 'utf8' и его открытие на чтение.
    # Запись всех символов из файла в переменную text.
    text = file.read()
    file.close()  # Закрытие файла file.
    ch_quantity = len(text)
    print(f"Общее количество символов в тексте: {ch_quantity}.")
    code = huffman_encode(text)  # Запуск функции кодирования текста методом Хаффмана.
    # Отображение закодированного текста путём отображения каждого символа соответств. кодом и объединением результата.
    encoded = "".join(code[ch] for ch in text)
    print("Кодирование символов методом Хаффмана:")
    # Обход символов в словаре в алфавитном порядке с помощью функции sorted().
    for ch in sorted(code):  # Для каждого символа ch в отсортированном словаре code:
        print("'{}': {}".format(ch, code[ch]))  # Вывод символа, кол-ва его повторений и соответствующего ему кода.
    # Создание файла "file_code.txt" с кодировкой 'utf8' и его открытие на запись.
    file_code = open("file_code.txt", "w", encoding='utf8')
    for ch in encoded:  # Для каждого символа ch в закодированном тексте encoded:
        file_code.write(ch)  # Запись данного символа в файл file_code.
    file_code.close()  # Закрытие файла file_code.
    print('Кодирование текста методом Хаффмана завершено. Результат сохранён в файл "file_code.txt".')

    # Оценка сжатия текста.

    print(f"Объём незакодированной фразы: V(text) = L(ASCII) = {ch_quantity} * 8 бит = {ch_quantity * 8} бит.")
    volume_code = 0  # Объём закодированной фразы.
    for ch, freq in Counter(text).items():  # Для каждого символа ch и кол-ва его повторений freq в тексте text:
        volume_code += len(code[ch]) * freq  # Кол-во символов в закод. символе * на кол-во повторений символа.
    print(f"Объём закодированной фразы: V(code) = L(Huff) = {volume_code} бит.")
    k = volume_code / (ch_quantity * 8)  # Коэффициент сжатия.
    k = float('{:.3f}'.format(k))  # Запись k с тремя знаками после запятой.
    print(f"Коэффициент сжатия: k = V(code) / V(text) = L(Huff) / L(ASCII) = "
          f"{volume_code} бит / {ch_quantity * 8} бит ≊ {k}.")

    # Нахождение средней величины и дисперсии.
    average_value = 0  # Средняя величина.
    average_quadratic_value = 0  # Средняя квадратичная величина.
    for ch, freq in Counter(text).items():  # Для каждого символа ch и кол-ва его повторений freq в тексте text:
        average_value += freq / len(text) * freq  # <вероятность> * <кол-во повторений символа>.
        average_quadratic_value += freq / len(text) * freq**2  # <вероятность> * <кол-во повторений символа>^(2).
    variance = average_quadratic_value - average_value**2  # Дисперсия.
    print(f"Средняя величина: M[X] ≊ {'{:.3f}'.format(average_value)}.")
    print(f"Квадрат средней величины: M²[X] ≊ {'{:.3f}'.format(average_value**2)}.")
    print(f"Средняя квадратичная величина: M[X²] ≊ {'{:.3f}'.format(average_quadratic_value)}.")
    print(f"Дисперсия: D[X] = M[X²] – M²[X] ≊ {'{:.3f}'.format(variance)}.")

    # Декодирование текста.

    file_decode = open("file_decode.txt", "w", encoding='utf8')
    decoded = huffman_decode(encoded, code)  # Запуск функции декодирования текста.
    for ch in decoded:  # Для каждого символа ch в расшифрованном тексте decoded:
        file_decode.write(ch)  # Запись данного символа в файл file_decode.
    file_decode.close()  # Закрытие файла file_decode.
    print('Декодирование текста методом Хаффмана завершено. Результат сохранён в файл "file_decode.txt".')


if __name__ == "__main__":
    main()
